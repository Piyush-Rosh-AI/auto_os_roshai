<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Auto OS: theta_star::ThetaStar Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Auto OS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>theta_star</b></li><li class="navelem"><a class="el" href="classtheta__star_1_1ThetaStar.html">ThetaStar</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classtheta__star_1_1ThetaStar-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">theta_star::ThetaStar Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for theta_star::ThetaStar:</div>
<div class="dyncontent">
<div class="center"><img src="classtheta__star_1_1ThetaStar__inherit__graph.png" border="0" usemap="#atheta__star_1_1ThetaStar_inherit__map" alt="Inheritance graph"/></div>
<map name="atheta__star_1_1ThetaStar_inherit__map" id="atheta__star_1_1ThetaStar_inherit__map">
<area shape="rect" title=" " alt="" coords="5,5,164,31"/>
<area shape="rect" href="classtest__theta__star.html" title=" " alt="" coords="25,79,145,104"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for theta_star::ThetaStar:</div>
<div class="dyncontent">
<div class="center"><img src="classtheta__star_1_1ThetaStar__coll__graph.png" border="0" usemap="#atheta__star_1_1ThetaStar_coll__map" alt="Collaboration graph"/></div>
<map name="atheta__star_1_1ThetaStar_coll__map" id="atheta__star_1_1ThetaStar_coll__map">
<area shape="rect" title=" " alt="" coords="139,123,298,148"/>
<area shape="rect" href="structcoordsM.html" title=" " alt="" coords="5,5,83,31"/>
<area shape="rect" href="classnav2__costmap__2d_1_1Costmap2D.html" title="A 2D costmap provides a mapping between points in the world and their associated &quot;costs&quot;." alt="" coords="107,5,331,31"/>
<area shape="rect" href="structtree__node.html" title=" " alt="" coords="355,5,442,31"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac90ac7321ce8678f7d87068d0859d336"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#ac90ac7321ce8678f7d87068d0859d336">generatePath</a> (std::vector&lt; <a class="el" href="structcoordsW.html">coordsW</a> &gt; &amp;raw_path, std::function&lt; bool()&gt; cancel_checker)</td></tr>
<tr class="memdesc:ac90ac7321ce8678f7d87068d0859d336"><td class="mdescLeft">&#160;</td><td class="mdescRight">it iteratively searches upon the nodes in the queue (open list) until the current node is the goal pose or the size of queue becomes 0  <br /></td></tr>
<tr class="separator:ac90ac7321ce8678f7d87068d0859d336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daac6c36c6740d41022e0875c9992df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#a8daac6c36c6740d41022e0875c9992df">isSafe</a> (const int &amp;cx, const int &amp;cy) const</td></tr>
<tr class="memdesc:a8daac6c36c6740d41022e0875c9992df"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function checks whether the cost of a point(cx, cy) on the costmap is less than the LETHAL_COST  <br /></td></tr>
<tr class="separator:a8daac6c36c6740d41022e0875c9992df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913fc34170477c4529b8b2aa80325a9e"><td class="memItemLeft" align="right" valign="top"><a id="a913fc34170477c4529b8b2aa80325a9e" name="a913fc34170477c4529b8b2aa80325a9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setStartAndGoal</b> (const geometry_msgs::msg::PoseStamped &amp;start, const geometry_msgs::msg::PoseStamped &amp;goal)</td></tr>
<tr class="memdesc:a913fc34170477c4529b8b2aa80325a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialises the values of the start and goal points <br /></td></tr>
<tr class="separator:a913fc34170477c4529b8b2aa80325a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603cc1debec5f4d9d138d2649bc67862"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#a603cc1debec5f4d9d138d2649bc67862">isUnsafeToPlan</a> () const</td></tr>
<tr class="memdesc:a603cc1debec5f4d9d138d2649bc67862"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks whether the start and goal points have costmap costs greater than LETHAL_COST  <br /></td></tr>
<tr class="separator:a603cc1debec5f4d9d138d2649bc67862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfa3598e72364a3bb000c2ac9b51ac4"><td class="memItemLeft" align="right" valign="top"><a id="acdfa3598e72364a3bb000c2ac9b51ac4" name="acdfa3598e72364a3bb000c2ac9b51ac4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearStart</b> ()</td></tr>
<tr class="memdesc:acdfa3598e72364a3bb000c2ac9b51ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear Start. <br /></td></tr>
<tr class="separator:acdfa3598e72364a3bb000c2ac9b51ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9f57f9cd921b309e1b9bc4e7e34d9483"><td class="memItemLeft" align="right" valign="top"><a id="a9f57f9cd921b309e1b9bc4e7e34d9483" name="a9f57f9cd921b309e1b9bc4e7e34d9483"></a>
<a class="el" href="structcoordsM.html">coordsM</a>&#160;</td><td class="memItemRight" valign="bottom"><b>src_</b> {}</td></tr>
<tr class="separator:a9f57f9cd921b309e1b9bc4e7e34d9483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15aa50c9a2177728befe5e8db7d36ac0"><td class="memItemLeft" align="right" valign="top"><a id="a15aa50c9a2177728befe5e8db7d36ac0" name="a15aa50c9a2177728befe5e8db7d36ac0"></a>
<a class="el" href="structcoordsM.html">coordsM</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dst_</b> {}</td></tr>
<tr class="separator:a15aa50c9a2177728befe5e8db7d36ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3040c01153df871ea9e6c2fdcb994ab"><td class="memItemLeft" align="right" valign="top"><a id="ab3040c01153df871ea9e6c2fdcb994ab" name="ab3040c01153df871ea9e6c2fdcb994ab"></a>
<a class="el" href="classnav2__costmap__2d_1_1Costmap2D.html">nav2_costmap_2d::Costmap2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>costmap_</b> {}</td></tr>
<tr class="separator:ab3040c01153df871ea9e6c2fdcb994ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f94b208725fc329b1dabd477654fcf1"><td class="memItemLeft" align="right" valign="top"><a id="a8f94b208725fc329b1dabd477654fcf1" name="a8f94b208725fc329b1dabd477654fcf1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>w_traversal_cost_</b></td></tr>
<tr class="memdesc:a8f94b208725fc329b1dabd477654fcf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">weight on the costmap traversal cost <br /></td></tr>
<tr class="separator:a8f94b208725fc329b1dabd477654fcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137083c618db19f24af6293bcb06b03a"><td class="memItemLeft" align="right" valign="top"><a id="a137083c618db19f24af6293bcb06b03a" name="a137083c618db19f24af6293bcb06b03a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>w_euc_cost_</b></td></tr>
<tr class="memdesc:a137083c618db19f24af6293bcb06b03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">weight on the euclidean distance cost (used for calculations of g_cost) <br /></td></tr>
<tr class="separator:a137083c618db19f24af6293bcb06b03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b087f06ec0fd6a5e2d08910d51661b"><td class="memItemLeft" align="right" valign="top"><a id="a14b087f06ec0fd6a5e2d08910d51661b" name="a14b087f06ec0fd6a5e2d08910d51661b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>w_heuristic_cost_</b></td></tr>
<tr class="memdesc:a14b087f06ec0fd6a5e2d08910d51661b"><td class="mdescLeft">&#160;</td><td class="mdescRight">weight on the heuristic cost (used for h_cost calculations) <br /></td></tr>
<tr class="separator:a14b087f06ec0fd6a5e2d08910d51661b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219854b9d9295aaf34e37ae888e32255"><td class="memItemLeft" align="right" valign="top"><a id="a219854b9d9295aaf34e37ae888e32255" name="a219854b9d9295aaf34e37ae888e32255"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>how_many_corners_</b></td></tr>
<tr class="memdesc:a219854b9d9295aaf34e37ae888e32255"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameter to set the number of adjacent nodes to be searched on <br /></td></tr>
<tr class="separator:a219854b9d9295aaf34e37ae888e32255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7522bd3bfa7b021b9336053381723bff"><td class="memItemLeft" align="right" valign="top"><a id="a7522bd3bfa7b021b9336053381723bff" name="a7522bd3bfa7b021b9336053381723bff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>allow_unknown_</b></td></tr>
<tr class="memdesc:a7522bd3bfa7b021b9336053381723bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameter to set weather the planner can plan through unknown space <br /></td></tr>
<tr class="separator:a7522bd3bfa7b021b9336053381723bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b7e7d09d7432064eaf2cd16b13e8d5"><td class="memItemLeft" align="right" valign="top"><a id="a23b7e7d09d7432064eaf2cd16b13e8d5" name="a23b7e7d09d7432064eaf2cd16b13e8d5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>size_x_</b></td></tr>
<tr class="memdesc:a23b7e7d09d7432064eaf2cd16b13e8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">the x-directional and y-directional lengths of the map respectively <br /></td></tr>
<tr class="separator:a23b7e7d09d7432064eaf2cd16b13e8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242895a2c4bf2e131e4dcd15050ca303"><td class="memItemLeft" align="right" valign="top"><a id="a242895a2c4bf2e131e4dcd15050ca303" name="a242895a2c4bf2e131e4dcd15050ca303"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>size_y_</b></td></tr>
<tr class="separator:a242895a2c4bf2e131e4dcd15050ca303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86742cbb7dd5836921d6cbf2c49171eb"><td class="memItemLeft" align="right" valign="top"><a id="a86742cbb7dd5836921d6cbf2c49171eb" name="a86742cbb7dd5836921d6cbf2c49171eb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>terminal_checking_interval_</b></td></tr>
<tr class="memdesc:a86742cbb7dd5836921d6cbf2c49171eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">the interval at which the planner checks if it has been cancelled <br /></td></tr>
<tr class="separator:a86742cbb7dd5836921d6cbf2c49171eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab864b74f418cea927b206a0f71d7ba5e"><td class="memItemLeft" align="right" valign="top"><a id="ab864b74f418cea927b206a0f71d7ba5e" name="ab864b74f418cea927b206a0f71d7ba5e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nodes_opened</b> = 0</td></tr>
<tr class="separator:ab864b74f418cea927b206a0f71d7ba5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad2e231b18cdbf4ee7cbcfcdae04c1d77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#ad2e231b18cdbf4ee7cbcfcdae04c1d77">resetParent</a> (<a class="el" href="structtree__node.html">tree_node</a> *curr_data)</td></tr>
<tr class="memdesc:ad2e231b18cdbf4ee7cbcfcdae04c1d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">it performs a line of sight (los) check between the current node and the parent node of its parent node; if an los is found and the new costs calculated are lesser, then the cost and parent node of the current node is updated  <br /></td></tr>
<tr class="separator:ad2e231b18cdbf4ee7cbcfcdae04c1d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8428a74ba52d6d56bfa7eebd8ec568b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#a8428a74ba52d6d56bfa7eebd8ec568b0">setNeighbors</a> (const <a class="el" href="structtree__node.html">tree_node</a> *curr_data)</td></tr>
<tr class="memdesc:a8428a74ba52d6d56bfa7eebd8ec568b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function expands the current node  <br /></td></tr>
<tr class="separator:a8428a74ba52d6d56bfa7eebd8ec568b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c743f14606cbfccd89f64aa096ef85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#a30c743f14606cbfccd89f64aa096ef85">losCheck</a> (const int &amp;x0, const int &amp;y0, const int &amp;x1, const int &amp;y1, double &amp;sl_cost) const</td></tr>
<tr class="memdesc:a30c743f14606cbfccd89f64aa096ef85"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the line of sight check using Bresenham's Algorithm, and has been modified to calculate the traversal cost incurred in a straight line path between the two points whose coordinates are (x0, y0) and (x1, y1)  <br /></td></tr>
<tr class="separator:a30c743f14606cbfccd89f64aa096ef85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37abb5b6ff5021d9891ec3bacd6db398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#a37abb5b6ff5021d9891ec3bacd6db398">backtrace</a> (std::vector&lt; <a class="el" href="structcoordsW.html">coordsW</a> &gt; &amp;raw_points, const <a class="el" href="structtree__node.html">tree_node</a> *curr_n) const</td></tr>
<tr class="memdesc:a37abb5b6ff5021d9891ec3bacd6db398"><td class="mdescLeft">&#160;</td><td class="mdescRight">it returns the path by backtracking from the goal to the start, by using their parent nodes  <br /></td></tr>
<tr class="separator:a37abb5b6ff5021d9891ec3bacd6db398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af871329575cbadf4285b7675a52be7f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#af871329575cbadf4285b7675a52be7f7">isSafe</a> (const int &amp;cx, const int &amp;cy, double &amp;cost) const</td></tr>
<tr class="memdesc:af871329575cbadf4285b7675a52be7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">it is an overloaded function to ease the cost calculations while performing the LOS check  <br /></td></tr>
<tr class="separator:af871329575cbadf4285b7675a52be7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8e70b688940fbce6ec6745b03e908f"><td class="memItemLeft" align="right" valign="top"><a id="aea8e70b688940fbce6ec6745b03e908f" name="aea8e70b688940fbce6ec6745b03e908f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getCost</b> (const int &amp;cx, const int &amp;cy) const</td></tr>
<tr class="separator:aea8e70b688940fbce6ec6745b03e908f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d2abdc98f36e153ef9b015bc8fb210"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#ab8d2abdc98f36e153ef9b015bc8fb210">getTraversalCost</a> (const int &amp;cx, const int &amp;cy)</td></tr>
<tr class="memdesc:ab8d2abdc98f36e153ef9b015bc8fb210"><td class="mdescLeft">&#160;</td><td class="mdescRight">for the point(cx, cy), its traversal cost is calculated by &lt;parameter&gt;*(&lt;actual_traversal_cost_from_costmap&gt;)^2/(&lt;max_cost&gt;)^2  <br /></td></tr>
<tr class="separator:ab8d2abdc98f36e153ef9b015bc8fb210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c93882032ed3cf45aa44e458c7d8f11"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#a5c93882032ed3cf45aa44e458c7d8f11">getEuclideanCost</a> (const int &amp;ax, const int &amp;ay, const int &amp;bx, const int &amp;by)</td></tr>
<tr class="memdesc:a5c93882032ed3cf45aa44e458c7d8f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the piecewise straight line euclidean distances by &lt;euc_cost_parameter&gt;*&lt;euclidean distance between the points (ax, ay) and (bx, by)&gt;  <br /></td></tr>
<tr class="separator:a5c93882032ed3cf45aa44e458c7d8f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45041236cbe7d83f418186b07124341"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#ab45041236cbe7d83f418186b07124341">getHCost</a> (const int &amp;cx, const int &amp;cy)</td></tr>
<tr class="memdesc:ab45041236cbe7d83f418186b07124341"><td class="mdescLeft">&#160;</td><td class="mdescRight">for the point(cx, cy), its heuristic cost is calculated by &lt;heuristic_cost_parameter&gt;*&lt;euclidean distance between the point and goal&gt;  <br /></td></tr>
<tr class="separator:ab45041236cbe7d83f418186b07124341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca7afeacf8582fefd1afaa6350b68ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#a3ca7afeacf8582fefd1afaa6350b68ca">withinLimits</a> (const int &amp;cx, const int &amp;cy) const</td></tr>
<tr class="memdesc:a3ca7afeacf8582fefd1afaa6350b68ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the given coordinates(cx, cy) lies within the map  <br /></td></tr>
<tr class="separator:a3ca7afeacf8582fefd1afaa6350b68ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359e5c139766765559d79da1d2e6a1e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#a359e5c139766765559d79da1d2e6a1e2">isGoal</a> (const <a class="el" href="structtree__node.html">tree_node</a> &amp;this_node) const</td></tr>
<tr class="memdesc:a359e5c139766765559d79da1d2e6a1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the coordinates of a node is the goal or not  <br /></td></tr>
<tr class="separator:a359e5c139766765559d79da1d2e6a1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a22070a6217803ab4b1fb6b4951a18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#a72a22070a6217803ab4b1fb6b4951a18">initializePosn</a> (int size_inc=0)</td></tr>
<tr class="memdesc:a72a22070a6217803ab4b1fb6b4951a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialises the node_position_ vector by storing -1 as index for all points(x, y) within the limits of the map  <br /></td></tr>
<tr class="separator:a72a22070a6217803ab4b1fb6b4951a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b4bc22a8d6f4d6761e718d6ef96df4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#a11b4bc22a8d6f4d6761e718d6ef96df4">addIndex</a> (const int &amp;cx, const int &amp;cy, <a class="el" href="structtree__node.html">tree_node</a> *node_this)</td></tr>
<tr class="memdesc:a11b4bc22a8d6f4d6761e718d6ef96df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">it stores id_this in node_position_ at the index [ size_x_*cy + cx ]  <br /></td></tr>
<tr class="separator:a11b4bc22a8d6f4d6761e718d6ef96df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbec59b2a2b4c2ccac259350f7c41cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtree__node.html">tree_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#a9bbec59b2a2b4c2ccac259350f7c41cf">getIndex</a> (const int &amp;cx, const int &amp;cy)</td></tr>
<tr class="memdesc:a9bbec59b2a2b4c2ccac259350f7c41cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieves the pointer of the location at which the data of the point(cx, cy) is stored in nodes_data  <br /></td></tr>
<tr class="separator:a9bbec59b2a2b4c2ccac259350f7c41cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae525a0c8ee6591599af991bc7083399a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#ae525a0c8ee6591599af991bc7083399a">addToNodesData</a> (const int &amp;id_this)</td></tr>
<tr class="memdesc:ae525a0c8ee6591599af991bc7083399a"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function depending on the size of the nodes_data_ vector allots space to store the data for a node(x, y)  <br /></td></tr>
<tr class="separator:ae525a0c8ee6591599af991bc7083399a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af601766187f8202a7852e1235819bec3"><td class="memItemLeft" align="right" valign="top"><a id="af601766187f8202a7852e1235819bec3" name="af601766187f8202a7852e1235819bec3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetContainers</b> ()</td></tr>
<tr class="memdesc:af601766187f8202a7852e1235819bec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialises the values of global variables at beginning of the execution of the generatePath function <br /></td></tr>
<tr class="separator:af601766187f8202a7852e1235819bec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec315903d78dcb572d301376a353c34"><td class="memItemLeft" align="right" valign="top"><a id="aeec315903d78dcb572d301376a353c34" name="aeec315903d78dcb572d301376a353c34"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearQueue</b> ()</td></tr>
<tr class="memdesc:aeec315903d78dcb572d301376a353c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears the priority queue after each execution of the generatePath function <br /></td></tr>
<tr class="separator:aeec315903d78dcb572d301376a353c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a03a1ca6da7e4e85204ea8b2637d71e36"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structtree__node.html">tree_node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#a03a1ca6da7e4e85204ea8b2637d71e36">node_position_</a></td></tr>
<tr class="separator:a03a1ca6da7e4e85204ea8b2637d71e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a147abb644a49ace59eefa8388ace5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structtree__node.html">tree_node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#a96a147abb644a49ace59eefa8388ace5">nodes_data_</a></td></tr>
<tr class="separator:a96a147abb644a49ace59eefa8388ace5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7219e5c68651503f5408934ed131f922"><td class="memItemLeft" align="right" valign="top"><a id="a7219e5c68651503f5408934ed131f922" name="a7219e5c68651503f5408934ed131f922"></a>
std::priority_queue&lt; <a class="el" href="structtree__node.html">tree_node</a> *, std::vector&lt; <a class="el" href="structtree__node.html">tree_node</a> * &gt;, <a class="el" href="structcomp.html">comp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>queue_</b></td></tr>
<tr class="memdesc:a7219e5c68651503f5408934ed131f922"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is the priority queue (open_list) to select the next node to be expanded <br /></td></tr>
<tr class="separator:a7219e5c68651503f5408934ed131f922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab289a57cd38afd1195abeadb7db086cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#ab289a57cd38afd1195abeadb7db086cf">index_generated_</a></td></tr>
<tr class="separator:ab289a57cd38afd1195abeadb7db086cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd96ece70850a85e80d3b85de466be6e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structcoordsM.html">coordsM</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtheta__star_1_1ThetaStar.html#acd96ece70850a85e80d3b85de466be6e">moves</a> [8]</td></tr>
<tr class="separator:acd96ece70850a85e80d3b85de466be6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6704c01a524ce3a36cb8117fe2615751"><td class="memItemLeft" align="right" valign="top"><a id="a6704c01a524ce3a36cb8117fe2615751" name="a6704c01a524ce3a36cb8117fe2615751"></a>
<a class="el" href="structtree__node.html">tree_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>exp_node</b></td></tr>
<tr class="separator:a6704c01a524ce3a36cb8117fe2615751"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a11b4bc22a8d6f4d6761e718d6ef96df4" name="a11b4bc22a8d6f4d6761e718d6ef96df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b4bc22a8d6f4d6761e718d6ef96df4">&#9670;&#160;</a></span>addIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theta_star::ThetaStar::addIndex </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtree__node.html">tree_node</a> *&#160;</td>
          <td class="paramname"><em>node_this</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>it stores id_this in node_position_ at the index [ size_x_*cy + cx ] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_this</td><td>a pointer to the location at which the data of the point(cx, cy) is stored in nodes_data_ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae525a0c8ee6591599af991bc7083399a" name="ae525a0c8ee6591599af991bc7083399a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae525a0c8ee6591599af991bc7083399a">&#9670;&#160;</a></span>addToNodesData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theta_star::ThetaStar::addToNodesData </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id_this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function depending on the size of the nodes_data_ vector allots space to store the data for a node(x, y) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_this</td><td>is the index at which the data is stored/has to be stored for that node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37abb5b6ff5021d9891ec3bacd6db398" name="a37abb5b6ff5021d9891ec3bacd6db398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37abb5b6ff5021d9891ec3bacd6db398">&#9670;&#160;</a></span>backtrace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theta_star::ThetaStar::backtrace </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcoordsW.html">coordsW</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>raw_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtree__node.html">tree_node</a> *&#160;</td>
          <td class="paramname"><em>curr_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>it returns the path by backtracking from the goal to the start, by using their parent nodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_points</td><td>used to return the path thus found </td></tr>
    <tr><td class="paramname">curr_id</td><td>sends in the index of the goal coordinate, as stored in nodes_position </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac90ac7321ce8678f7d87068d0859d336" name="ac90ac7321ce8678f7d87068d0859d336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90ac7321ce8678f7d87068d0859d336">&#9670;&#160;</a></span>generatePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool theta_star::ThetaStar::generatePath </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcoordsW.html">coordsW</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>raw_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool()&gt;&#160;</td>
          <td class="paramname"><em>cancel_checker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>it iteratively searches upon the nodes in the queue (open list) until the current node is the goal pose or the size of queue becomes 0 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_path</td><td>is used to return the path obtained by executing the algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a path is found, false if no path is found in between the start and goal pose </dd></dl>

</div>
</div>
<a id="a5c93882032ed3cf45aa44e458c7d8f11" name="a5c93882032ed3cf45aa44e458c7d8f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c93882032ed3cf45aa44e458c7d8f11">&#9670;&#160;</a></span>getEuclideanCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double theta_star::ThetaStar::getEuclideanCost </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>by</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates the piecewise straight line euclidean distances by &lt;euc_cost_parameter&gt;*&lt;euclidean distance between the points (ax, ay) and (bx, by)&gt; </p>
<dl class="section return"><dt>Returns</dt><dd>the distance thus calculated </dd></dl>

</div>
</div>
<a id="ab45041236cbe7d83f418186b07124341" name="ab45041236cbe7d83f418186b07124341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45041236cbe7d83f418186b07124341">&#9670;&#160;</a></span>getHCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double theta_star::ThetaStar::getHCost </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>for the point(cx, cy), its heuristic cost is calculated by &lt;heuristic_cost_parameter&gt;*&lt;euclidean distance between the point and goal&gt; </p>
<dl class="section return"><dt>Returns</dt><dd>the heuristic cost </dd></dl>

</div>
</div>
<a id="a9bbec59b2a2b4c2ccac259350f7c41cf" name="a9bbec59b2a2b4c2ccac259350f7c41cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbec59b2a2b4c2ccac259350f7c41cf">&#9670;&#160;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtree__node.html">tree_node</a> * theta_star::ThetaStar::getIndex </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>retrieves the pointer of the location at which the data of the point(cx, cy) is stored in nodes_data </p>
<dl class="section return"><dt>Returns</dt><dd>id_this is the pointer to that location </dd></dl>

</div>
</div>
<a id="ab8d2abdc98f36e153ef9b015bc8fb210" name="ab8d2abdc98f36e153ef9b015bc8fb210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d2abdc98f36e153ef9b015bc8fb210">&#9670;&#160;</a></span>getTraversalCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double theta_star::ThetaStar::getTraversalCost </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>for the point(cx, cy), its traversal cost is calculated by &lt;parameter&gt;*(&lt;actual_traversal_cost_from_costmap&gt;)^2/(&lt;max_cost&gt;)^2 </p>
<dl class="section return"><dt>Returns</dt><dd>the traversal cost thus calculated </dd></dl>

</div>
</div>
<a id="a72a22070a6217803ab4b1fb6b4951a18" name="a72a22070a6217803ab4b1fb6b4951a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a22070a6217803ab4b1fb6b4951a18">&#9670;&#160;</a></span>initializePosn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theta_star::ThetaStar::initializePosn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size_inc</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initialises the node_position_ vector by storing -1 as index for all points(x, y) within the limits of the map </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_inc</td><td>is used to increase the number of elements in node_position_ in case the size of the map increases </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a359e5c139766765559d79da1d2e6a1e2" name="a359e5c139766765559d79da1d2e6a1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359e5c139766765559d79da1d2e6a1e2">&#9670;&#160;</a></span>isGoal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theta_star::ThetaStar::isGoal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtree__node.html">tree_node</a> &amp;&#160;</td>
          <td class="paramname"><em>this_node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the coordinates of a node is the goal or not </p>
<dl class="section return"><dt>Returns</dt><dd>the result of the check </dd></dl>

</div>
</div>
<a id="a8daac6c36c6740d41022e0875c9992df" name="a8daac6c36c6740d41022e0875c9992df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8daac6c36c6740d41022e0875c9992df">&#9670;&#160;</a></span>isSafe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theta_star::ThetaStar::isSafe </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function checks whether the cost of a point(cx, cy) on the costmap is less than the LETHAL_COST </p>
<dl class="section return"><dt>Returns</dt><dd>the result of the check </dd></dl>

</div>
</div>
<a id="af871329575cbadf4285b7675a52be7f7" name="af871329575cbadf4285b7675a52be7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af871329575cbadf4285b7675a52be7f7">&#9670;&#160;</a></span>isSafe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theta_star::ThetaStar::isSafe </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>it is an overloaded function to ease the cost calculations while performing the LOS check </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cost</td><td>denotes the total straight line traversal cost; it adds the traversal cost for the node (cx, cy) at every instance; it is also being returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the traversal cost is greater than / equal to the LETHAL_COST and true otherwise </dd></dl>

</div>
</div>
<a id="a603cc1debec5f4d9d138d2649bc67862" name="a603cc1debec5f4d9d138d2649bc67862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603cc1debec5f4d9d138d2649bc67862">&#9670;&#160;</a></span>isUnsafeToPlan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theta_star::ThetaStar::isUnsafeToPlan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks whether the start and goal points have costmap costs greater than LETHAL_COST </p>
<dl class="section return"><dt>Returns</dt><dd>true if the cost of any one of the points is greater than LETHAL_COST </dd></dl>

</div>
</div>
<a id="a30c743f14606cbfccd89f64aa096ef85" name="a30c743f14606cbfccd89f64aa096ef85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c743f14606cbfccd89f64aa096ef85">&#9670;&#160;</a></span>losCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theta_star::ThetaStar::losCheck </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sl_cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs the line of sight check using Bresenham's Algorithm, and has been modified to calculate the traversal cost incurred in a straight line path between the two points whose coordinates are (x0, y0) and (x1, y1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl_cost</td><td>is used to return the cost thus incurred </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a line of sight exists between the points </dd></dl>

</div>
</div>
<a id="ad2e231b18cdbf4ee7cbcfcdae04c1d77" name="ad2e231b18cdbf4ee7cbcfcdae04c1d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e231b18cdbf4ee7cbcfcdae04c1d77">&#9670;&#160;</a></span>resetParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theta_star::ThetaStar::resetParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtree__node.html">tree_node</a> *&#160;</td>
          <td class="paramname"><em>curr_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>it performs a line of sight (los) check between the current node and the parent node of its parent node; if an los is found and the new costs calculated are lesser, then the cost and parent node of the current node is updated </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>of the current node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8428a74ba52d6d56bfa7eebd8ec568b0" name="a8428a74ba52d6d56bfa7eebd8ec568b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8428a74ba52d6d56bfa7eebd8ec568b0">&#9670;&#160;</a></span>setNeighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void theta_star::ThetaStar::setNeighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtree__node.html">tree_node</a> *&#160;</td>
          <td class="paramname"><em>curr_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function expands the current node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr_data</td><td>used to send the data of the current node </td></tr>
    <tr><td class="paramname">curr_id</td><td>used to send the index of the current node as stored in nodes_position_ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ca7afeacf8582fefd1afaa6350b68ca" name="a3ca7afeacf8582fefd1afaa6350b68ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca7afeacf8582fefd1afaa6350b68ca">&#9670;&#160;</a></span>withinLimits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool theta_star::ThetaStar::withinLimits </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>cy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks if the given coordinates(cx, cy) lies within the map </p>
<dl class="section return"><dt>Returns</dt><dd>the result of the check </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab289a57cd38afd1195abeadb7db086cf" name="ab289a57cd38afd1195abeadb7db086cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab289a57cd38afd1195abeadb7db086cf">&#9670;&#160;</a></span>index_generated_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int theta_star::ThetaStar::index_generated_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>it is a counter like variable used to generate consecutive indices such that the data for all the nodes (in open and closed lists) could be stored consecutively in nodes_data_ </p>

</div>
</div>
<a id="acd96ece70850a85e80d3b85de466be6e" name="acd96ece70850a85e80d3b85de466be6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd96ece70850a85e80d3b85de466be6e">&#9670;&#160;</a></span>moves</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structcoordsM.html">coordsM</a> theta_star::ThetaStar::moves[8]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{0, 1},</div>
<div class="line">    {0, -1},</div>
<div class="line">    {1, 0},</div>
<div class="line">    {-1, 0},</div>
<div class="line">    {1, -1},</div>
<div class="line">    {-1, 1},</div>
<div class="line">    {1, 1},</div>
<div class="line">    {-1, -1}}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a03a1ca6da7e4e85204ea8b2637d71e36" name="a03a1ca6da7e4e85204ea8b2637d71e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a1ca6da7e4e85204ea8b2637d71e36">&#9670;&#160;</a></span>node_position_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structtree__node.html">tree_node</a> *&gt; theta_star::ThetaStar::node_position_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>for the coordinates (x,y), it stores at node_position_[size_x_ * y + x], the pointer to the location at which the data of the node is present in nodes_data_ it is initialised with size_x_ * size_y_ elements and its number of elements increases to account for a change in map size </p>

</div>
</div>
<a id="a96a147abb644a49ace59eefa8388ace5" name="a96a147abb644a49ace59eefa8388ace5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a147abb644a49ace59eefa8388ace5">&#9670;&#160;</a></span>nodes_data_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structtree__node.html">tree_node</a>&gt; theta_star::ThetaStar::nodes_data_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the vector nodes_data_ stores the coordinates, costs and index of the parent node, and whether or not the node is present in queue_, for all the nodes searched it is initialised with no elements and its size increases depending on the number of nodes searched </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>nav2_pkgs/nav2_theta_star_planner/include/nav2_theta_star_planner/<a class="el" href="theta__star_8hpp_source.html">theta_star.hpp</a></li>
<li>nav2_pkgs/nav2_theta_star_planner/src/theta_star.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
